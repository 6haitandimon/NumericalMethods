# Импортируем библиотеку NumPy для работы с матрицами
import numpy as np

# Определяем функцию, которая принимает квадратную матрицу A и возвращает ее LDLT-факторизацию
def ldlt_factorization(A):
    # Проверяем, что матрица A квадратная и симметричная
    n = A.shape[0]
    assert A.shape == (n, n), "Матрица A должна быть квадратной"
    assert np.allclose(A, A.T), "Матрица A должна быть симметричной"
    
    # Инициализируем матрицы L и D
    L = np.eye(n) # Единичная матрица размера n
    D = np.zeros((n, n)) # Нулевая матрица размера n
    
    # Проходим по диагональным элементам матрицы A
    for i in range(n):
        # Вычисляем диагональный элемент матрицы D
        D[i, i] = A[i, i] - np.sum(L[i, :i] ** 2 * D[:i, :i])
        
        # Вычисляем недиагональные элементы матрицы L
        for j in range(i + 1, n):
            L[j, i] = (A[j, i] - np.sum(L[j, :i] * L[i, :i] * D[:i, :i])) / D[i, i]
    
    # Возвращаем матрицы L и D
    return L, D

# Определяем функцию, которая принимает матрицу A и вектор b и решает систему Ax = b методом LDLT-факторизации
def ldlt_solve(A, b):
    # Получаем LDLT-факторизацию матрицы A
    L, D = ldlt_factorization(A)
    
    # Решаем систему Ly = b методом прямой подстановки
    y = np.linalg.solve(L, b)
    
    # Решаем систему Dz = y методом прямой подстановки
    z = np.linalg.solve(D, y)
    
    # Решаем систему L^Tx = z методом обратной подстановки
    x = np.linalg.solve(L.T, z)
    
    # Возвращаем вектор x
    return x

# Пример использования функции ldlt_solve для решения системы Ax = b

# Задаем матрицу A и вектор b
A = np.array([[6, 13, -17],
            [13, 29, -38], 
            [-17, -38, 50]])
b = np.array([2, 4, -5])

# Решаем систему Ax = b методом LDLT-факторизации
x = ldlt_solve(A, b)

# Выводим результат на экран
print("Решение системы Ax = b:")
print(x)
